# -*- coding: utf-8 -*-
"""app0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17H0b2rVFyPhP_2BoztLHuCd-PPV-0l-I
"""

import streamlit as st
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.colors


tab1, tab2, tab3, tab4 = st.tabs(["Home", "Opinions", "Enviormental Concern","Links/References"])

with tab1:
    st.header("Virtual Worlds; Real Problems")
    st.write("The research examines how immersive environmental video games can influence players' climate awareness and concern. By exploring the link between virtual experiences and real-world attitudes, it highlights the potential of games as powerful tools for climate communication and education.")
    st.write("As a case study, we chose to examine Animal Crossing: New Horizons, a popular game that emphasizes interactions with the in-game enviornment. Players are incentivized to gather resources for use in crafting items or building amenities (like a general store) for the island. They are also prompted to collect bugs, fish, and fossils to donate to the museum, sell, or display. This environmental interaction is the focus of this study. ")
    st.write("Visit the Opinions & Enviornmental Concerns tabs to view visualizations representing our findings.")

with tab2:
    df = pd.read_csv('gameData.csv')
    df = df[df['A1'] != "What is your nationality?"]

    conditions = [
        df['A1'].isin(['Vietnam', 'Japan', 'China','Philippines','Indonesia','Singapore','Myanmar']),
        df['A1'].isin(['Canada', 'USA'])
    ]

    choices = ['Asia', 'North America']

    df['A1_Region'] = np.select(conditions, choices, default='Other')

    for col in ["C1", "C2", "C3","C4", "C5", "C6","C7", "C8", "C9","C10", "C11", "C12","C13", "C14", "C15","D5"]:
        df[col] = pd.to_numeric(df[col], errors="coerce")
    df.fillna(0, inplace=True)

    for col in ["C7", "C8", "C9"]:
        df[col] = 6 - df[col]

    df[['C7', 'C8', 'C9']] = df[['C7', 'C8', 'C9']].clip(0, 5)

    st.header("Opinions of ACNH Players")


    df['Resource Limits and Overpopulation'] = (df[['C1', 'C11']].sum(axis=1)) / 2
    df['Human Impact on the Environment'] = (df[['C3', 'C5', 'C15']].sum(axis=1)) / 3
    df['Natures Balance and Fragility'] = (df[['C8', 'C13']].sum(axis=1)) / 2
    df['Human Superiority vs. Ecocentrism'] = (df[['C2', 'C12', 'C7', 'C9']].sum(axis=1)) / 4
    df['Technological Optimism vs. Environmental Concern'] = (df[['C4', 'C14', 'C10', 'C6']].sum(axis=1)) / 4

    y_tick_labels = {
        'Resource Limits and Overpopulation': ["Resources are Plentiful", "Resources are Limited"],
        'Human Impact on the Environment': ["Humans Have Little Impact", "Humans Harm the Environment"],
        'Natures Balance and Fragility': ["Nature is Resilient", "Nature is Fragile"],
        'Human Superiority vs. Ecocentrism': ["Humans Should Dominate Nature", "Nature is Equal to Humans"],
        'Technological Optimism vs. Environmental Concern': ["Tech Will Save Us", "Environment in Danger"],
    }


    column_names = ['Resource Limits and Overpopulation',
                'Human Impact on the Environment',
                'Natures Balance and Fragility',
                'Human Superiority vs. Ecocentrism',
                'Technological Optimism vs. Environmental Concern']

    # Selectbox for user to choose a column name
    selected_y_column = st.selectbox(
        'Select the agreement statement to analyze:',
        column_names
    )
    df = df[df['D5'] != 7]

    reverse_mapping = {1: 6, 2: 5, 3: 4, 4: 3, 5: 2, 6: 1}

    df['D5_reversed'] = df['D5'].map(reverse_mapping)

    x = df['D5_reversed'].astype('category').cat.codes


    # Define the function for plotting
    def update_plot(selected_y_column):
        # Use the actual numeric values, not category codes
        y = df[selected_y_column]

        countries = df['A1_Region'].astype('category')
        country_labels = countries.cat.categories
        color_values = countries.cat.codes

        jitter_strength = 0.5
        x_jittered = x + np.random.uniform(-jitter_strength, jitter_strength, size=len(x))
        y_jittered = y + np.random.uniform(-jitter_strength, jitter_strength, size=len(y))

        plt.figure(figsize=(10, 8))

        cmap = matplotlib.colors.ListedColormap(sns.color_palette("colorblind", as_cmap=False))

        # Scatter plot using actual y values (no category conversion)
        scatter = plt.scatter(x_jittered, y_jittered, c=color_values, cmap=cmap, alpha=0.8)

        # Create custom legend
        handles = []
        for i, country in enumerate(country_labels):
            hex_color = matplotlib.colors.to_hex(cmap(i % len(cmap.colors)))  # Use the colorblind-safe palette
            handles.append(plt.Line2D([0], [0], marker='o', color='w',
                                    label=country,
                                    markerfacecolor=hex_color, markersize=6))

        plt.legend(handles=handles, title='Region', loc='upper right', framealpha=0.9, fontsize='small', title_fontsize='medium')

        # Best fit line
        slope, intercept = np.polyfit(x_jittered, y_jittered, 1)
        line_x = np.linspace(x_jittered.min(), x_jittered.max(), 100)
        line_y = slope * line_x + intercept
        plt.plot(line_x, line_y, color='red', label='Best Fit Line')

        # R-squared calculation
        correlation_matrix = np.corrcoef(x_jittered, y_jittered)
        correlation_coefficient = correlation_matrix[0, 1]
        r_squared = correlation_coefficient ** 2

        if selected_y_column in y_tick_labels:
            plt.yticks([1, 5], y_tick_labels[selected_y_column], rotation=90)
            for label in plt.gca().get_yticklabels():
                label.set_verticalalignment('center')

        plt.xticks([1, 6], ["Less than once a month", "Everyday"])


        plt.text(0.95, 0.05, f'R² = {r_squared:.2f}',
         transform=plt.gca().transAxes,
         fontsize=12,
         verticalalignment='bottom',
         horizontalalignment='right')
        
        plt.title(f'Fig 1. Opinion on: {selected_y_column} by Time Playing ACNH', fontweight='bold', fontsize=16, pad=20)
        plt.xlabel('Time Spent Playing ACNH', fontweight='bold')
        plt.ylabel("Opinion", fontweight='bold')


        plt.tight_layout()  # Default tight layout is enough now

        st.pyplot(plt)


    # Call the update_plot function to render the plot
    update_plot(selected_y_column)
    st.write("Fig 1. analyzes players' opinions on various enviormental topics, mapped to the frequency they play New Horizons. Topics can be selected between, and the graph includes both a line of best fit and the R^2 correlation coefficient. The line of best fit shows the general trend of player opinions, while the correlation coefficient shows the degree of correlation between the data and the trend on a scale of 0-1, with 0 being weakly correlated and 1 being very strongly correlated.")


with tab3:
    st.header("ACNH Players Compared to Global Population")

    dfglobal = pd.read_csv("globalData.csv")
    dfglobal["Country"] = dfglobal["Country"].str.strip().str.upper()


    dfglobal = dfglobal.dropna(subset=["Weighted Mean", "Question Text (Short)", "Response", "Country"])

    # Define accurate agreement responses (based on real data)
    agree_map = {
        "Big businesses performance": ["Very well", "Somewhat well"],
        "Countries working together": ["Yes - they should work together despite their disagreements"],
        "Country performance": ["Very well", "Somewhat well"],
        "Effects on big decisions": ["A lot"],
        "Extreme weather experience": ["Worse than usual"],
        "Protect and restore nature": ["A lot"],
        "Protection from extreme weather": ["More protection"],
        "Renewable energy transition": ["Very quickly", "Somewhat quickly"],
        "Rich countries helping poor": ["More help"],
        "Strengthening commitments": ["Strengthen"],
        "Teaching about climate change": ["More"],
        "Thinking about climate change": ["Daily", "Weekly"],
        "Worry compared to last year": ["More worried"],
        "Worry for next generation": ["Extremely", "Very","Somewhat"]
    }

    # Filter and combine agree responses
    agree_rows = []
    for question, agree_responses in agree_map.items():
        subset = dfglobal[(dfglobal["Question Text (Short)"] == question) & (dfglobal["Response"].isin(agree_responses))]
        agree_rows.append(subset)

    df_agree = pd.concat(agree_rows)

    pivot_df = df_agree.pivot_table(
        index="Country",
        columns="Question Text (Short)",
        values="Weighted Mean",
        aggfunc="mean"  # Use mean to average the agreement percentages
    )

    pivot_df.columns.name = None
    pivot_df = pivot_df.sort_index()

    global_row = pivot_df.mean(axis=0)

    # Add it as a new row
    pivot_df.loc["GLOBAL"] = global_row

    # --- Step 1: Clean up gameData like before ---
    df_game = pd.read_csv("gameData.csv")

    country_col_game = 'A1'  # Country
    gender_col = 'A2'        # Gender (adjust if needed)
    agree_cols_game = [f'C{i}' for i in range(1, 16)]  # C1 to C15

    # Normalize country to uppercase (make sure it's consistent)
    df_game[country_col_game] = df_game[country_col_game].str.strip().str.upper()


    # Normalize gender to title case (if needed, it might be inconsistent like "Male" vs "male")
    df_game[gender_col] = df_game[gender_col].str.strip().str.title()

    # Clean agreement columns (convert to numeric and binarize)
    df_game[agree_cols_game] = df_game[agree_cols_game].apply(pd.to_numeric, errors='coerce').fillna(0)
    df_game[agree_cols_game] = df_game[agree_cols_game].apply(lambda x: (x >= 4).astype(int))

    # --- Step 2: Country-only agreement ---
    country_agreement_game = df_game.groupby(country_col_game)[agree_cols_game].mean() * 100
    country_agreement_game = country_agreement_game.reset_index()
    country_agreement_game.columns = [f"Agree: {col}" if col != country_col_game else "Country" for col in country_agreement_game.columns]

    # --- Step 3: Country-Gender agreement ---
    # Create a combined "Country - Gender" label
    df_game['Country-Gender'] = df_game[country_col_game] + " - " + df_game[gender_col]

    # Group by this new label
    country_gender_agreement = df_game.groupby('Country-Gender')[agree_cols_game].mean() * 100
    country_gender_agreement = country_gender_agreement.reset_index()
    country_gender_agreement.columns = [f"Agree: {col}" if col != 'Country-Gender' else "Country" for col in country_gender_agreement.columns]

    # --- Step 4: Combine both ---
    # Stack the two datasets together
    full_agreement_game = pd.concat([country_agreement_game, country_gender_agreement], ignore_index=True)

    # Optional: Sort by country name for easier reading
    full_agreement_game = full_agreement_game.sort_values(by="Country").reset_index(drop=True)

    global_overall = df_game[agree_cols_game].mean() * 100
    global_overall["Country"] = "GLOBAL"
    global_overall = global_overall.rename(lambda x: f"Agree: {x}" if x not in ["Country"] else x)

    # 2. Global - Male
    global_male = df_game[df_game[gender_col] == "Male"][agree_cols_game].mean() * 100
    global_male["Country"] = "GLOBAL - Male"
    global_male = global_male.rename(lambda x: f"Agree: {x}" if x not in ["Country"] else x)

    # 3. Global - Female
    global_female = df_game[df_game[gender_col] == "Female"][agree_cols_game].mean() * 100
    global_female["Country"] = "GLOBAL - Female"
    global_female = global_female.rename(lambda x: f"Agree: {x}" if x not in ["Country"] else x)

    # 4. Stack them into a DataFrame
    global_rows = pd.DataFrame([global_overall, global_male, global_female])

    # --- Step 7: Final final table! ---
    full_agreement_game = pd.concat([full_agreement_game, global_rows], ignore_index=True)

    # Optional again: re-sort so "Global" is at the top if you want
    full_agreement_game = full_agreement_game.sort_values(by="Country").reset_index(drop=True)



    # --- Step 1: Merge the datasets using an inner join ---
    final_merged = full_agreement_game.merge(pivot_df, how="inner", on="Country")

    # --- Step 2: Make sure only the countries that exist in both datasets are kept ---
    # We already used "inner" join in the merge, so only countries that exist in both datasets remain

    # --- Step 3: Keep rows that are gendered (i.e., rows where "Country" contains " - ") ---
    # Filter the gendered rows
    final_merged_gendered = final_merged[final_merged["Country"].str.contains(" - ")]

    # --- Step 4: Combine gendered and non-gendered data into one dataset ---
    final_merged_non_gendered = final_merged[~final_merged["Country"].str.contains(" - ")]

    # Combine the two parts
    final_merged_combined = pd.concat([final_merged_non_gendered, final_merged_gendered], ignore_index=True)

    # --- Step 5: Ensure the global row is always the leftmost ---
    # Identify the global row(s), assuming "Country" is 'Global' for the global data
    global_row = final_merged_combined[final_merged_combined["Country"] == "GLOBAL"]

    # Remove the global row from the dataset (it'll be re-added first)
    final_merged_combined = final_merged_combined[final_merged_combined["Country"] != "GLOBAL"]

    # Re-add the global row(s) at the front of the dataframe
    final_merged_combined = pd.concat([global_row, final_merged_combined], ignore_index=True)

    # --- Step 6: Sort by country name for easier reading ---
    final_merged_combined = final_merged_combined.sort_values(by="Country").reset_index(drop=True)

    #st.write(final_merged_combined.columns)

    # --- Step 1: Prepare the data as you provided ---

    # Filter out gendered rows and ensure global is first
    plot_data = final_merged_combined[["Country", "Strengthening commitments", "Agree: C15"]].copy()

    # Drop rows where both values are NaN (in case)
    plot_data = plot_data.dropna(subset=["Strengthening commitments", "Agree: C15"], how='all')

    # Filter out gendered rows
    plot_data = plot_data[~plot_data["Country"].str.contains(" - ")]

    # --- Step 2: Ensure the global row is first ---
    # Extract the global row
    global_row_plot = plot_data[plot_data["Country"] == "GLOBAL"]

    # Remove the global row from the dataset
    plot_data = plot_data[plot_data["Country"] != "GLOBAL"]

    # Concatenate the global row first for plotting
    plot_data = pd.concat([global_row_plot, plot_data], ignore_index=True)

    # --- Step 3: Make x-axis locations and set up bar widths ---
    x = np.arange(len(plot_data))  # label locations
    width = 0.35  # width of the bars

    # --- Step 4: Create the plot ---
    fig, ax = plt.subplots(figsize=(15, 8))  # make the figure bigger if you have a lot of countries

    # Bars
    rects1 = ax.bar(x - width/2, plot_data["Strengthening commitments"], width, label="General Population")
    rects2 = ax.bar(x + width/2, plot_data["Agree: C15"], width, label="ACNH Players")

    # Labels, Title, etc

    plt.title('Fig 2. Percentage of Population Concerned for Environmental Future', fontweight='bold', fontsize=18, pad=20)
    plt.xlabel('Country', fontweight='bold',fontsize=14)
    plt.ylabel("Percentage", fontweight='bold',fontsize=14)

    ax.set_xticks(x)
    ax.set_xticklabels(plot_data["Country"], rotation=90)
    ax.legend()

    def autolabel(rects):
        for rect in rects:
            height = rect.get_height()
            if not np.isnan(height):
                ax.annotate(f'{height:.1f}%',
                            xy=(rect.get_x() + rect.get_width() / 2, height),
                            xytext=(0, 3),  # 3 points vertical offset
                            textcoords="offset points",
                            ha='center', va='bottom', fontsize=8)

    autolabel(rects1)
    autolabel(rects2)

    # Layout tweak
    fig.tight_layout()

    # Show the plot in Streamlit
    st.pyplot(fig)
    st.write("Fig 2. compares the percentage of select countries' population that are concerned about the enviornment. The percentages for each country are split between the general population and players of Animal Crossing: New Horizons.")
with tab4:
    st.header("Links and References")
    st.markdown("[Our Github](https://github.com/hollai465/FinalProject)")
    st.markdown("[Dataset 1: A multinational dataset of game players’ behaviors in a virtual world and environmental perceptions](https://www.scidb.cn/en/detail?dataSetId=cb5d36cce29f4e5695a586c9b85d04b6&dataSetType=journal)")
    st.markdown("[Dataset 2: The People's Climate Vote](https://peoplesclimate.vote/data-center)")
