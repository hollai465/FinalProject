# -*- coding: utf-8 -*-
"""app0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17H0b2rVFyPhP_2BoztLHuCd-PPV-0l-I
"""

import streamlit as st
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np

# Load the data
df = pd.read_csv('gameData.csv')

# Set the Streamlit app title
st.title('ACNH Player Agreement Analysis')

# Define the column descriptions for the dropdown
column_descriptions = {
    'C1': 'We are approaching the limit of the number of people the earth can support',
    'C2': 'Humans have the right to modify the natural environment to suit their needs.',
    'C3': 'When humans interfere with nature it often produces disastrous consequences.',
    'C4': 'Human ingenuity will insure that we do not make the Earth unlivable',
    'C5': 'Humans are seriously abusing the environment.',
    'C6': 'The Earth has plenty of natural resources if we just learn how to develop them.',
    'C7': 'Plants and animals have as much right as humans to exist.',
    'C8': 'The balance of nature is strong enough to cope with the impacts of modern industrial nations.',
    'C9': 'Despite our special abilities, humans are still subject to the laws of nature.',
    'C10': 'The so-called “ecological crisis” facing humankind has been greatly exaggerated.',
    'C11': 'The Earth is like a spaceship with very limited room and resources.',
    'C12': 'Humans were meant to rule over the rest of nature.',
    'C13': 'The balance of nature is very delicate and easily upset.',
    'C14': 'Humans will eventually learn enough about how nature works to be able to control it.',
    'C15': 'If things continue on their present course, we will soon experience a major ecological catastrophe.'
}

# Create a dropdown for selecting the column to plot
selected_y_column = st.selectbox('Select the agreement statement to analyze:', list(column_descriptions.keys()), format_func=lambda x: column_descriptions[x])

# Prepare the x values (this part remains unchanged)
x = df['D5'].str[0].astype('category').cat.codes

# Define the function for plotting
def update_plot(selected_y_column):
    y = df[selected_y_column].str[0].astype('category').cat.codes

    jitter_strength = 0.5
    x_jittered = x + np.random.uniform(-jitter_strength, jitter_strength, size=len(x))
    y_jittered = y + np.random.uniform(-jitter_strength, jitter_strength, size=len(y))

    plt.figure(figsize=(8, 6))
    plt.scatter(x_jittered, y_jittered)

    slope, intercept = np.polyfit(x_jittered, y_jittered, 1)  # 1 for linear fit
    line_x = np.linspace(x_jittered.min(), x_jittered.max(), 100)
    line_y = slope * line_x + intercept

    plt.plot(line_x, line_y, color='red', label='Best Fit Line')

    y_pred = slope * x_jittered + intercept  # Predicted y values from the line
    correlation_matrix = np.corrcoef(x_jittered, y_jittered)
    correlation_coefficient = correlation_matrix[0, 1]
    r_squared = correlation_coefficient ** 2  # R-squared

    plt.text(0.05, 0.95, f'R² = {r_squared:.2f}', transform=plt.gca().transAxes, fontsize=12, verticalalignment='top')

    # Show legend
    plt.legend()

    plt.title(f'Agreement with Statement: {column_descriptions[selected_y_column]}')
    plt.xlabel('Time Spent Playing ACNH')
    plt.ylabel("Level of Agreement (Strongly Disagree - Strongly Agree)")

    # Display the plot
    st.pyplot(plt)

# Call the update_plot function to render the plot
update_plot(selected_y_column)


# --- Bar Chart Section ---



dfglobal = pd.read_csv("globalData.csv")
dfglobal["Country"] = dfglobal["Country"].str.strip().str.upper()


dfglobal = dfglobal.dropna(subset=["Weighted Mean", "Question Text (Short)", "Response", "Country"])

# Define accurate agreement responses (based on real data)
agree_map = {
    "Big businesses performance": ["Very well", "Somewhat well"],
    "Countries working together": ["Yes - they should work together despite their disagreements"],
    "Country performance": ["Very well", "Somewhat well"],
    "Effects on big decisions": ["A lot"],
    "Extreme weather experience": ["Worse than usual"],
    "Protect and restore nature": ["A lot"],
    "Protection from extreme weather": ["More protection"],
    "Renewable energy transition": ["Very quickly", "Somewhat quickly"],
    "Rich countries helping poor": ["More help"],
    "Strengthening commitments": ["Strengthen"],
    "Teaching about climate change": ["More"],
    "Thinking about climate change": ["Daily", "Weekly"],
    "Worry compared to last year": ["More worried"],
    "Worry for next generation": ["Extremely", "Very","Somewhat"]
}

# Filter and combine agree responses
agree_rows = []
for question, agree_responses in agree_map.items():
    subset = dfglobal[(dfglobal["Question Text (Short)"] == question) & (dfglobal["Response"].isin(agree_responses))]
    agree_rows.append(subset)

df_agree = pd.concat(agree_rows)

pivot_df = df_agree.pivot_table(
    index="Country",
    columns="Question Text (Short)",
    values="Weighted Mean",
    aggfunc="mean"  # Use mean to average the agreement percentages
)

pivot_df.columns.name = None
pivot_df = pivot_df.sort_index()

global_row = pivot_df.mean(axis=0)

# Add it as a new row
pivot_df.loc["GLOBAL"] = global_row

# --- Step 1: Clean up gameData like before ---
df_game = pd.read_csv("gameData.csv")

country_col_game = 'A1'  # Country
gender_col = 'A2'        # Gender (adjust if needed)
agree_cols_game = [f'C{i}' for i in range(1, 16)]  # C1 to C15

# Normalize country to uppercase (make sure it's consistent)
df_game[country_col_game] = df_game[country_col_game].str.strip().str.upper()


# Normalize gender to title case (if needed, it might be inconsistent like "Male" vs "male")
df_game[gender_col] = df_game[gender_col].str.strip().str.title()

# Clean agreement columns (convert to numeric and binarize)
df_game[agree_cols_game] = df_game[agree_cols_game].apply(pd.to_numeric, errors='coerce').fillna(0)
df_game[agree_cols_game] = df_game[agree_cols_game].apply(lambda x: (x >= 4).astype(int))

# --- Step 2: Country-only agreement ---
country_agreement_game = df_game.groupby(country_col_game)[agree_cols_game].mean() * 100
country_agreement_game = country_agreement_game.reset_index()
country_agreement_game.columns = [f"Agree: {col}" if col != country_col_game else "Country" for col in country_agreement_game.columns]

# --- Step 3: Country-Gender agreement ---
# Create a combined "Country - Gender" label
df_game['Country-Gender'] = df_game[country_col_game] + " - " + df_game[gender_col]

# Group by this new label
country_gender_agreement = df_game.groupby('Country-Gender')[agree_cols_game].mean() * 100
country_gender_agreement = country_gender_agreement.reset_index()
country_gender_agreement.columns = [f"Agree: {col}" if col != 'Country-Gender' else "Country" for col in country_gender_agreement.columns]

# --- Step 4: Combine both ---
# Stack the two datasets together
full_agreement_game = pd.concat([country_agreement_game, country_gender_agreement], ignore_index=True)

# Optional: Sort by country name for easier reading
full_agreement_game = full_agreement_game.sort_values(by="Country").reset_index(drop=True)

global_overall = df_game[agree_cols_game].mean() * 100
global_overall["Country"] = "GLOBAL"
global_overall = global_overall.rename(lambda x: f"Agree: {x}" if x not in ["Country"] else x)

# 2. Global - Male
global_male = df_game[df_game[gender_col] == "Male"][agree_cols_game].mean() * 100
global_male["Country"] = "GLOBAL - Male"
global_male = global_male.rename(lambda x: f"Agree: {x}" if x not in ["Country"] else x)

# 3. Global - Female
global_female = df_game[df_game[gender_col] == "Female"][agree_cols_game].mean() * 100
global_female["Country"] = "GLOBAL - Female"
global_female = global_female.rename(lambda x: f"Agree: {x}" if x not in ["Country"] else x)

# 4. Stack them into a DataFrame
global_rows = pd.DataFrame([global_overall, global_male, global_female])

# --- Step 7: Final final table! ---
full_agreement_game = pd.concat([full_agreement_game, global_rows], ignore_index=True)

# Optional again: re-sort so "Global" is at the top if you want
full_agreement_game = full_agreement_game.sort_values(by="Country").reset_index(drop=True)



# --- Step 1: Merge the datasets using an inner join ---
final_merged = full_agreement_game.merge(pivot_df, how="inner", on="Country")

# --- Step 2: Make sure only the countries that exist in both datasets are kept ---
# We already used "inner" join in the merge, so only countries that exist in both datasets remain

# --- Step 3: Keep rows that are gendered (i.e., rows where "Country" contains " - ") ---
# Filter the gendered rows
final_merged_gendered = final_merged[final_merged["Country"].str.contains(" - ")]

# --- Step 4: Combine gendered and non-gendered data into one dataset ---
final_merged_non_gendered = final_merged[~final_merged["Country"].str.contains(" - ")]

# Combine the two parts
final_merged_combined = pd.concat([final_merged_non_gendered, final_merged_gendered], ignore_index=True)

# --- Step 5: Ensure the global row is always the leftmost ---
# Identify the global row(s), assuming "Country" is 'Global' for the global data
global_row = final_merged_combined[final_merged_combined["Country"] == "GLOBAL"]

# Remove the global row from the dataset (it'll be re-added first)
final_merged_combined = final_merged_combined[final_merged_combined["Country"] != "GLOBAL"]

# Re-add the global row(s) at the front of the dataframe
final_merged_combined = pd.concat([global_row, final_merged_combined], ignore_index=True)

# --- Step 6: Sort by country name for easier reading ---
final_merged_combined = final_merged_combined.sort_values(by="Country").reset_index(drop=True)

#st.write(final_merged_combined.columns)

import matplotlib.pyplot as plt
import numpy as np

# --- Step 1: Prepare the data as you provided ---

# Filter out gendered rows and ensure global is first
plot_data = final_merged_combined[["Country", "Strengthening commitments", "Agree: C15"]].copy()

# Drop rows where both values are NaN (in case)
plot_data = plot_data.dropna(subset=["Strengthening commitments", "Agree: C15"], how='all')

# Filter out gendered rows
plot_data = plot_data[~plot_data["Country"].str.contains(" - ")]

# --- Step 2: Ensure the global row is first ---
# Extract the global row
global_row_plot = plot_data[plot_data["Country"] == "GLOBAL"]

# Remove the global row from the dataset
plot_data = plot_data[plot_data["Country"] != "GLOBAL"]

# Concatenate the global row first for plotting
plot_data = pd.concat([global_row_plot, plot_data], ignore_index=True)

# --- Step 3: Make x-axis locations and set up bar widths ---
x = np.arange(len(plot_data))  # label locations
width = 0.35  # width of the bars

# --- Step 4: Create the plot ---
fig, ax = plt.subplots(figsize=(15, 8))  # make the figure bigger if you have a lot of countries

# Bars
rects1 = ax.bar(x - width/2, plot_data["Strengthening commitments"], width, label="General Population")
rects2 = ax.bar(x + width/2, plot_data["Agree: C15"], width, label="ACNH Players")

# Labels, Title, etc
ax.set_ylabel('Percentage')
ax.set_xlabel('Country')
ax.set_title('Percentage of Population Concerned for Environmental Future')
ax.set_xticks(x)
ax.set_xticklabels(plot_data["Country"], rotation=90)
ax.legend()

# Optional: Add percentages above bars
def autolabel(rects):
    for rect in rects:
        height = rect.get_height()
        if not np.isnan(height):
            ax.annotate(f'{height:.1f}%',
                        xy=(rect.get_x() + rect.get_width() / 2, height),
                        xytext=(0, 3),  # 3 points vertical offset
                        textcoords="offset points",
                        ha='center', va='bottom', fontsize=8)

autolabel(rects1)
autolabel(rects2)

# Layout tweak
fig.tight_layout()

# Show the plot in Streamlit
st.pyplot(fig)
